{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Clustering Methods\"\n",
        "subtitle: \"IN2004B: Generation of Value with Data Analytics\"\n",
        "author: \n",
        "  - name: Alan R. Vazquez\n",
        "    affiliations:\n",
        "      - name: Department of Industrial Engineering\n",
        "format: \n",
        "  revealjs:\n",
        "    chalkboard: false\n",
        "    multiplex: false\n",
        "    footer: \"Tecnologico de Monterrey\"\n",
        "    logo: IN1002b_logo.png\n",
        "    css: style.css\n",
        "    slide-number: True\n",
        "    html-math-method: mathjax\n",
        "editor: visual\n",
        "jupyter: python3\n",
        "---\n",
        "\n",
        "\n",
        "## Agenda\n",
        "\n",
        "</br>\n",
        "\n",
        "1.  Aprendizaje Sin Supervisión\n",
        "2.  Métodos de agrupamiento\n",
        "    -   Método de K-Medias\n",
        "    -   Agrupación Jerárquica\n",
        "\n",
        "# Aprendizaje Sin Supervisión\n",
        "\n",
        "## Tipos de Aprendizaje\n",
        "\n",
        "En ciencia de datos, existen dos tipos principales de aprendizaje:\n",
        "\n",
        "-   [Aprendizaje supervisado (*supervised learning*)]{style=\"color:blue;\"}. En el cual tenemos varios predictores y una respuesta. El objetivo es predecir la respuesta usando los valores de los predictores.\n",
        "\n",
        "-   [Aprendizaje sin supervisión (*unsupervised learning*)]{style=\"color:green;\"}. En el cual solo tenemos varios predictores. El objetivo es descubrir patrones en sus datos.\n",
        "\n",
        "## Tipos de Aprendizaje\n",
        "\n",
        "En ciencia de datos, existen dos tipos principales de aprendizaje:\n",
        "\n",
        "-   [Aprendizaje supervisado (*supervised learning*). En el cual tenemos varios predictores y una respuesta. El objetivo es predecir la respuesta usando los valores de los predictores.]{style=\"color:gray;\"}\n",
        "\n",
        "-   [Aprendizaje sin supervisión (*unsupervised learning*)]{style=\"color:green;\"}. En el cual solo tenemos varios predictores. El objetivo es descubrir patrones en sus datos.\n",
        "\n",
        "## Aprendizaje Sin Supervisión\n",
        "\n",
        "Su objetivo es organizar o *agrupar* datos para obtener información.\n",
        "\n",
        "Contesta preguntas como:\n",
        "\n",
        "-   ¿Existe una forma informativa de visualizar los datos?\n",
        "-   ¿Podemos descubrir subgrupos entre las variables o entre las observaciones?\n",
        "\n",
        "El aprendizaje sin supervisión es más desafiante que el aprendizaje supervisado porque que [**es subjetivo**]{style=\"color:darkgreen;\"} y no existe un objetivo simple para el análisis, como predecir una respuesta.\n",
        "\n",
        "El aprendizaje sn supervisión también se le conoce como *análisis exploratorio de datos*.\n",
        "\n",
        "## Ejemplos de aprendizaje sin supervisión\n",
        "\n",
        "-   *Marketing.* Identificar un segmento de clientes que poseen una alta tendencia a adquirir un producto específico.\n",
        "\n",
        "-   *Retail.* Agrupar clientes según sus preferencias, estilo, elección de ropa y preferencias de tienda.\n",
        "\n",
        "-   *Ciencia médica.* Facilitar el diagnóstico y tratamiento eficiente de sus pacientes así como el descubrimiento de nuevos medicamentos.\n",
        "\n",
        "-   *Sociología.* Clasifique a las personas según su demografía, estilo de vida, nivel socioeconómico, etc.\n",
        "\n",
        "## Métodos de aprendizaje sin supervisión\n",
        "\n",
        "Los [**Métodos de Agrupamiento**]{style=\"color:pink;\"} tienen como objetivo encontrar subgrupos con datos similares en la base de datos.\n",
        "\n",
        "El [**Análisis de Componentes Principales**]{style=\"color:aqua;\"} busca una representación alternativa de los datos para facilitar su comprensión cuando hay muchos predictores en la base de datos.\n",
        "\n",
        "Aquí nos usaremos estos métodos en predictores $X_1, X_2, \\ldots, X_p$ que son numéricos.\n",
        "\n",
        "## Métodos de aprendizaje sin supervisión\n",
        "\n",
        "Los [**Métodos de Agrupamiento**]{style=\"color:pink;\"} tienen como objetivo encontrar subgrupos con datos similares en la base de datos.\n",
        "\n",
        "[El **Análisis de Componentes Principales** busca una representación alternativa de los datos para facilitar su comprensión cuando hay muchos predictores en la base de datos.]{style=\"color:gray;\"}\n",
        "\n",
        "Aquí nos usaremos estos métodos en predictores $X_1, X_2, \\ldots, X_p$ que son numéricos.\n",
        "\n",
        "# Métodos de agrupamiento\n",
        "\n",
        "Agrupan los datos de diferentes maneras para descubrir grupos con rasgos comunes entre ellos.\n",
        "\n",
        "![](images/clipboard-4025099075.png)\n",
        "\n",
        "## Métodos de agrupamiento\n",
        "\n",
        "Dos métodos clásicos de agrupamiento son:\n",
        "\n",
        "-   [**Método K-medias**]{style=\"color:pink;\"}. Buscamos dividir las observaciones en *K* grupos.\n",
        "\n",
        "-   [**Agrupación jerárquica**]{style=\"color:darkpink;\"}. Dividimos las *n* observaciones en 1 grupos, 2 grupos, 3 grupos, ..., hasta *n* grupos. Visualizamos las divisiones usando una gráfica llamada *dendrograma*.\n",
        "\n",
        "## Ejemplo\n",
        "\n",
        "La base de datos “penguins.xlsx” contiene datos sobre 342 pingüinos en la Antártida. Los datos contienen:\n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"60%\"}\n",
        "-   Longitud del pico (bill length) en milimetros.\n",
        "-   Profundidad del pico (bill depth) en milimetros.\n",
        "-   Longitud de la aleta (flipper length) en milimetros\n",
        "-   Peso (body mass) en gramos.\n",
        ":::\n",
        "\n",
        "::: {.column width=\"40%\"}\n",
        "![](images/clipboard-2240851715.png)\n",
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "¿Podemos agrupar los pingüinos en base a estas características?\n",
        "\n",
        "## Datos\n",
        "\n",
        "Python\n",
        "\n",
        "## Visualización de datos\n",
        "\n",
        "Scatter plots\n",
        "\n",
        "# Método de K-Medias\n",
        "\n",
        "## El método de K-medias\n",
        "\n",
        "**Objetivo**: Encontrar *K* grupos de observaciones tal que cada observación está en un grupo diferente.\n",
        "\n",
        "![](images/clipboard-3145794211.png)\n",
        "\n",
        "## \n",
        "\n",
        "</br>\n",
        "\n",
        "Para esto, el método necesita dos elementos:\n",
        "\n",
        "A. Una medida de “cercanía” entre observaciones. B. Un algoritmo que agrupe observaciones que están cercanas entre sí.\n",
        "\n",
        "Una buena agrupación es aquella en la que las observaciones dentro de un grupo están cerca y las observaciones en diferentes grupos están lejos.\n",
        "\n",
        "## ¿Cómo medimos la distancia entre observaciones?\n",
        "\n",
        "Para predictores cuantitativos, utilizamos la **distancia euclidiana**.\n",
        "\n",
        "Por ejemplo, si tenemos dos predictores $X_1$ y $X_2$ con observaciones dadas en la tabla:\n",
        "\n",
        "| Observación | (X_1)      | (X_2)      |\n",
        "|-------------|------------|------------|\n",
        "| 1           | (X\\_{1,1}) | (X\\_{1,2}) |\n",
        "| 2           | (X\\_{2,1}) | (X\\_{2,2}) |\n",
        "\n",
        "## \n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"50%\"}\n",
        "La distancia euclideana es\n",
        "\n",
        "$$d = \\sqrt{(X_{1,1} - X_{2,1})^2 + (X_{1,2} - X_{2,2})^2 }$$\n",
        ":::\n",
        "\n",
        "::: {.column width=\"50%\"}\n",
        "![](images/distancia_euclideana.png)\n",
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "## \n",
        "\n",
        "Podemos extender la distancia euclidiana para medir la distancia entre observaciones cuando tenemos más predictores. Por ejemplo, con 3 predictores tenemos\n",
        "\n",
        "| Observación | (X_1)      | (X_2)      | (X_3)      |\n",
        "|-------------|------------|------------|------------|\n",
        "| 1           | (X\\_{1,1}) | (X\\_{1,2}) | (X\\_{1,3}) |\n",
        "| 2           | (X\\_{2,1}) | (X\\_{2,2}) | (X\\_{2,3}) |\n",
        "\n",
        "Donde la distancia euclideana es\n",
        "\n",
        "$$d = \\sqrt{(X_{1,1} - X_{2,1})^2 + (X_{1,2} - X_{2,2})^2 + (X_{1,3} - X_{2,3})^2 }$$\n",
        "\n",
        "## Problema con la distancia euclidiana\n",
        "\n",
        "-   La distancia euclidiana depende de las unidades de medición de los predictores!\n",
        "\n",
        "-   Predictores con ciertas unidades tienen mayor relevancia en el cálculo de la distancia.\n",
        "\n",
        "-   Esto no es bueno ya que queremos que todos los predictores tengan la misma importancia al calcular la distancia euclidiana entre dos observaciones.\n",
        "\n",
        "-   La solución es **estandarizar** las unidades de los predictores.\n",
        "\n",
        "## Algoritmo de K-medias\n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"60%\"}\n",
        "Elige un valor para *K*, el número de grupos.\n",
        "\n",
        "1.  Asigna observaciones aleatoriamente a uno de los *K* grupos.\n",
        "2.  Encuentra los *centroides* (puntos promedio) de cada grupo.\n",
        "3.  Reasigna observaciones al grupo del centroide más cercano.\n",
        "4.  Repite los pasos 3, 4 hasta que no haya más cambios.\n",
        ":::\n",
        "\n",
        "::: {.column width=\"40%\"}\n",
        "![](images/clipboard-1847659123.png)\n",
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "## K medias en Python\n",
        "\n",
        "TBD\n",
        "\n",
        "## Estos 3 grupos son 3 especies de pingüinos\n",
        "\n",
        "::::::: center\n",
        ":::::: columns\n",
        "::: {.column width=\"33%\"}\n",
        "Adelie (Grupo 1)\n",
        "\n",
        "![](images/clipboard-1367554877.png)\n",
        ":::\n",
        "\n",
        "::: {.column width=\"33%\"}\n",
        "Gentoo (Grupo 2)\n",
        "\n",
        "![](images/clipboard-3518959291.png)\n",
        ":::\n",
        "\n",
        "::: {.column width=\"33%\"}\n",
        "Chinstrap (Grupo 3)\n",
        "\n",
        "![](images/clipboard-2663292782.png)\n",
        ":::\n",
        "::::::\n",
        ":::::::\n",
        "\n",
        "## Comentarios\n",
        "\n",
        "-   Seleccionar el número de grupos *K* es más un arte que una ciencia. Será mejor que aciertes con *K*, o estarás detectando patrones donde en verdad no los hay.\n",
        "\n",
        "-   Necesitamos estandarizar todos los predictores.\n",
        "\n",
        "-   El rendimiento de la agrupación por *K*-medias se ve afectado por la presencia de valores atípicos.\n",
        "\n",
        "-   La solución del algoritmo es sensible al punto de partida. Por esto, normalmente se ejecuta varias veces y se reporta la mejor agrupación entre todas las ejecuciones.\n",
        "\n",
        "# Agrupación Jerárquica\n",
        "\n",
        "## Agrupación Jerárquica\n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"60%\"}\n",
        "-   Comienza con cada observación por sí sola en su propio grupo.\n",
        "\n",
        "-   Luego, fusiona gradualmente los grupos que están cerca unos de otros.\n",
        "\n",
        "-   Continuamos este proceso hasta que todas las observaciones estén en un grupo grande.\n",
        "\n",
        "-   Finalmente, damos un paso atrás y vemos qué agrupación funciona mejor.\n",
        ":::\n",
        "\n",
        "::: {.column width=\"40%\"}\n",
        "![](images/clipboard-2325345248.png)\n",
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "## Componentes Esenciales\n",
        "\n",
        "</br>\n",
        "\n",
        "1.  Distancia entre dos observaciones.\n",
        "\n",
        "-   Usamos la distancia euclidiana.\n",
        "-   Debemos de estandarizar los predictores!\n",
        "\n",
        "2.  Distancia entre [**dos grupos**]{style=\"color:darkgreen;\"}.\n",
        "\n",
        "## Distancia entre grupos.\n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"60%\"}\n",
        "La distancia entre dos grupos de observaciones se llama [***vinculación***]{style=\"color:pink;\"}.\n",
        "\n",
        "Hay varios tipos de vinculación. Los más usados son\n",
        "\n",
        "-   Vinculación completa\n",
        "-   Vinculación promedio\n",
        ":::\n",
        "\n",
        "::: {.column width=\"40%\"}\n",
        "![](images/vinculacion.png)\n",
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "## Vinculación Completa\n",
        "\n",
        "La distancia entre grupos se mide utilizando la mayor distancia entre observaciones.\n",
        "\n",
        "![](images/completa.png)\n",
        "\n",
        "## Promedio\n",
        "\n",
        "La distancia entre grupos es el promedio de todas las distancias entre observaciones.\n",
        "\n",
        "![](images/promedio.png)\n",
        "\n",
        "## Algoritmo de Agrupamiento Jerárquico\n",
        "\n",
        "Los pasos del algoritmo son los siguientes:\n",
        "\n",
        "1.  Asigna cada observación a un grupo.\n",
        "2.  Mide el vínculo entre todos los grupos.\n",
        "3.  Fusiona los dos grupos que sean más similares.\n",
        "4.  Luego, fusiona los dos siguientes grupos que sean más similares.\n",
        "5.  Continua hasta que todos los grupos hayan sido fusionados.\n",
        "\n",
        "## Ejemplo\n",
        "\n",
        "Consideremos un conjunto de datos en el archivo “Cereals.xlsx”. Los datos incluyen información nutricional de 77 cereales, entre otros datos.\n",
        "\n",
        "## En Python\n",
        "\n",
        "## Resultados: Dendrograma\n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"60%\"}\n",
        "-   Un dendrograma es un diagrama de arbol que resume y visualiza el proceso de agrupamiento.\n",
        "-   Las observaciones estan en el eje horizontal y en la parte inferior del diagrama.\n",
        "-   El eje vertical muestra la distancia entre los grupos.\n",
        "-   Se lee de arriba a abajo.\n",
        ":::\n",
        "\n",
        "::: {.column width=\"40%\"}\n",
        "![](images/clipboard-2041051251.png)\n",
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "## ¿Qué hacer con un dendrograma?\n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"60%\"}\n",
        "Dibujamos una linea horizontal a una altura específica para definir los grupos.\n",
        "\n",
        "Esta linea define 3 grupos.\n",
        ":::\n",
        "\n",
        "::: {.column width=\"40%\"}\n",
        "![](images/dendrograma1.png)\n",
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "## \n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"60%\"}\n",
        "Esta linea define 5 grupos.\n",
        ":::\n",
        "\n",
        "::: {.column width=\"40%\"}\n",
        "![](images/dendrograma2.png)\n",
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "## Dendrograma en Python\n",
        "\n",
        "## Comentarios\n",
        "\n",
        "- Recuerda que debemos estandarizar los predictores!\n",
        "\n",
        "- No es sencillo elegir el número correcto de grupos usando el dendrograma.\n",
        "\n",
        "- Los resultados dependen de la medida de vinculación utilizada.\n",
        "  - La vinculación completa resulta en grupos más estrechos.\n",
        "  - La vinculación promedio logra un equilibrio entre grupos estrechos y más delgados.\n",
        "\n",
        "- La agrupación jerárquica es útil para detectar valores atípicos.\n",
        "\n",
        "## \n",
        "\n",
        "</br>\n",
        "</br>\n",
        "\n",
        "> *Con estos métodos, no existe una única respuesta correcta; se debe considerar cualquier solución que exponga algunos aspectos interesantes de los datos.* \n",
        "\n",
        "James et al. (2017)\n",
        "\n",
        "\n",
        "\n",
        "# [Return to main page](https://alanrvazquez.github.io/TEC-IN1002B-Website/)"
      ],
      "id": "f26e55f7"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}