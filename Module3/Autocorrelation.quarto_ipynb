{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Autocorrelation Models\"\n",
        "subtitle: \"IN2004B: Generation of Value with Data Analytics\"\n",
        "author: \n",
        "  - name: Alan R. Vazquez\n",
        "    affiliations:\n",
        "      - name: Department of Industrial Engineering\n",
        "format: \n",
        "  revealjs:\n",
        "    chalkboard: false\n",
        "    multiplex: false\n",
        "    footer: \"Tecnologico de Monterrey\"\n",
        "    logo: IN2004B_logo.png\n",
        "    css: style.css\n",
        "    slide-number: True\n",
        "    html-math-method: mathjax\n",
        "editor: visual\n",
        "jupyter: python3\n",
        "---\n",
        "\n",
        "\n",
        "## Agenda\n",
        "\n",
        "</br>\n",
        "\n",
        "1.  Autocorrelation\n",
        "2.  The ARIMA model\n",
        "3.  The SARIMA model\n",
        "\n",
        "## Load the libraries\n",
        "\n",
        "Before we start, let's import the data science libraries into Python.\n"
      ],
      "id": "81f5a70d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: false\n",
        "\n",
        "# Importing necessary libraries\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.linear_model import LinearRegression\n",
        "from sklearn.metrics import mean_squared_error\n",
        "from statsmodels.graphics.tsaplots import plot_acf, plot_pacf\n",
        "from statsmodels.tsa.arima.model import ARIMA\n",
        "from statsmodels.tsa.statespace.tools import diff"
      ],
      "id": "0d53c298",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Here, we use specific functions from the **pandas**, **matplotlib**, **seaborn**, **sklearn** and **statsmodels** libraries in Python.\n",
        "\n",
        "## statsmodels library\n",
        "\n",
        "-   **statsmodels** is a powerful Python library for statistical modeling, data analysis, and hypothesis testing.\n",
        "-   It provides classes and functions for estimating statistical models.\n",
        "-   It is built on top of libraries such as **NumPy**, **SciPy**, and **pandas**\n",
        "-   <https://www.statsmodels.org/stable/index.html>\n",
        "\n",
        "![](images/statsmodels-logo-v2-horizontal-dark.svg){fig-align=\"center\"}\n",
        "\n",
        "## Problem with linear regression models\n",
        "\n",
        "</br>\n",
        "\n",
        "Linear regression models do not incorporate the [dependence]{style=\"color:purple;\"} between consecutive values in a time series.\n",
        "\n",
        "This is unfortunate because responses recorded over close time periods tend to be correlated. This correlation is called the [**autocorrelation**]{style=\"color:purple;\"} of the time series.\n",
        "\n",
        "Autocorrelation helps us develop a model that can make better predictions of future responses.\n",
        "\n",
        "## What is correlation?\n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"60%\"}\n",
        "</br>\n",
        "\n",
        "-   It is a measure of the strength and direction of the *linear* relationship between two numerical variables.\n",
        "\n",
        "-   Specifically, it is used to assess the relationship between two sets of observations.\n",
        "\n",
        "-   Correlation is between $-1$ and 1.\n",
        ":::\n",
        "\n",
        "::: {.column width=\"40%\"}\n",
        "</br>\n"
      ],
      "id": "0d0dacb2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "# Load the data into Python\n",
        "Ads_data = pd.read_excel('Advertising.xlsx')\n",
        "\n",
        "# Calculate correlation\n",
        "correlation = Ads_data['TV'].corr(Ads_data['Sales'])\n",
        "\n",
        "# Create scatter plot\n",
        "plt.figure(figsize=(5, 5))\n",
        "sns.scatterplot(data=Ads_data, x='TV', y='Sales')\n",
        "plt.xlabel('TV Advertising Budget')\n",
        "plt.ylabel('Sales')\n",
        "# Optionally, also add as text on the plot\n",
        "plt.text(0.05, 0.95, f'Correlation = {correlation:.2f}', transform=plt.gca().transAxes,\n",
        "         fontsize=12, color='blue', ha='left', va='top')\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "e741e441",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "## How do we measure autocorrelation?\n",
        "\n",
        "</br></br></br>\n",
        "\n",
        "There are two formal tools for measuring the correlation between observations in a time series:\n",
        "\n",
        "::: incremental\n",
        "-   The [***autocorrelation***]{style=\"color:green;\"} function.\n",
        "\n",
        "-   The [***partial autocorrelation***]{style=\"color:purple;\"} function.\n",
        ":::\n",
        "\n",
        "## The autocorrelation function\n",
        "\n",
        "> Measures the correlation between responses separated by $j$ periods.\n",
        "\n",
        "For example, consider the autocorrelation between the current temperature and the temperature recorded the day before.\n",
        "\n",
        ". . .\n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"50%\"}\n",
        "![](images/correlation_1.png){fig-align=\"center\" width=\"465\" height=\"288\"}\n",
        ":::\n",
        "\n",
        "::: {.column width=\"50%\"}\n",
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "## The autocorrelation function\n",
        "\n",
        "> Measures the correlation between responses separated by $j$ periods.\n",
        "\n",
        "For example, consider the autocorrelation between the current temperature and the temperature recorded the day before.\n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"50%\"}\n",
        "![](images/correlation_1.png){fig-align=\"center\" width=\"465\" height=\"288\"}\n",
        ":::\n",
        "\n",
        "::: {.column width=\"50%\"}\n",
        "![](images/correlation_2.png){fig-align=\"center\" width=\"465\" height=\"288\"}\n",
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "## The autocorrelation function\n",
        "\n",
        "> Measures the correlation between responses separated by $j$ periods.\n",
        "\n",
        "For example, consider the autocorrelation between the current temperature and the temperature recorded the day before. This would be the correlation between these two columns\n",
        "\n",
        "![](images/correlation_combined.png){fig-align=\"center\"}\n",
        "\n",
        "## Example 1\n",
        "\n",
        "Let's consider again the dataset in the file \"Amtrak.xlsx.\" The file contains records of Amtrak passenger numbers from January 1991 to March 2004.\n"
      ],
      "id": "b9ffcebd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "Amtrak_data = pd.read_excel('Amtrak.xlsx')\n",
        "Amtrak_data.head()"
      ],
      "id": "770d0eda",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "</br>\n"
      ],
      "id": "f4f04d48"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "sns.lineplot(x='Month', y='Ridership (in 000s)', data = Amtrak_data)\n",
        "plt.xlabel('Month')\n",
        "plt.ylabel('Ridership')\n",
        "plt.title('Amtrak Ridership Over Time')\n",
        "plt.show()"
      ],
      "id": "7650fbd8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Autocorrelation function\n",
        "\n",
        "</br>\n",
        "\n",
        "-   The autocorrelation function measures the correlation between responses that are separated by a specific number of periods.\n",
        "\n",
        "-   The autocorrelation function is commonly visualized using a bar chart.\n",
        "\n",
        "-   The horizontal axis shows the differences (or [*lags*]{style=\"color:brown;\"}) between the periods considered, and the vertical axis shows the correlations between observations at different lags.\n",
        "\n",
        "## Autocorrelation plot\n",
        "\n",
        "</br>\n",
        "\n",
        "In Python, we use the `plot_acf` function from the **statsmodels** library.\n"
      ],
      "id": "1bf2dbd5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: false\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "plot_acf(Amtrak_data['Ridership (in 000s)'], lags = 25)\n",
        "plt.xlabel(\"Lag\")\n",
        "plt.ylabel(\"Correlation\")\n",
        "plt.show()"
      ],
      "id": "d1227f01",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The `lags` parameter controls the number of periods for which to compute the autocorrelation function.\n",
        "\n",
        "## The resulting plot\n",
        "\n",
        "</br>\n"
      ],
      "id": "525f3822"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "plot_acf(Amtrak_data['Ridership (in 000s)'], lags = 25)\n",
        "plt.xlabel(\"Lag\")\n",
        "plt.ylabel(\"Correlation\")\n",
        "plt.show()"
      ],
      "id": "d4443174",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "::::::: center\n",
        ":::::: columns\n",
        ":::: {.column width=\"50%\"}\n",
        "::: {style=\"font-size: 80%;\"}\n",
        "</br>\n",
        "\n",
        "-   The autocorrelation plot shows that the responses and those from zero periods ago have a correlation of 1.\n",
        "\n",
        "-   The autocorrelation plot shows that the responses and those from one period ago have a correlation of around 0.45.\n",
        "\n",
        "-   The autocorrelation plot shows that the responses and those from 24 periods ago have a correlation of around 0.5.\n",
        ":::\n",
        "::::\n",
        "\n",
        "::: {.column width=\"50%\"}\n",
        "</br>\n"
      ],
      "id": "96afb3ab"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=(4, 4))\n",
        "plot_acf(Amtrak_data['Ridership (in 000s)'], lags = 25)\n",
        "plt.xlabel(\"Lag\")\n",
        "plt.ylabel(\"Correlation\")\n",
        "plt.show()"
      ],
      "id": "8ac68a27",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "::::::\n",
        ":::::::\n",
        "\n",
        "## Autocorrelation patterns\n",
        "\n",
        "</br>\n",
        "\n",
        "-   **A strong autocorrelation (positive or negative) with a lag** $j$ **greater than 1 and its multiples** ($2k, 3k, \\ldots$) typically reflects a cyclical pattern or seasonality.\n",
        "\n",
        "-   **Positive lag-1 autocorrelation** describes a series in which consecutive values *generally* move in the same direction.\n",
        "\n",
        "-   **Negative lag-1 autocorrelation** reflects oscillations in the series, where high values (*generally*) are immediately followed by low values and vice versa.\n",
        "\n",
        "## More about the autocorrelation function\n",
        "\n",
        "Consider the problem of predicting the average price of a kilo of avocado this month.\n",
        "\n",
        "For this, we have the average price from last month and the month before that.\n",
        "\n",
        "![](images/Avocado1.png){fig-align=\"center\"}\n",
        "\n",
        "## \n",
        "\n",
        "</br></br>\n",
        "\n",
        "The autocorrelation function for $Y_t$ and $Y_{t-2}$ includes the direct and indirect effect of $Y_{t-2}$ on $Y_t$.\n",
        "\n",
        "![](images/Avocado3.png){fig-align=\"center\"}\n",
        "\n",
        "## Partial autocorrelation function\n",
        "\n",
        "> Measures the correlation between responses that are separated by $j$ periods, **excluding correlation** due to responses separated by intervening periods.\n",
        "\n",
        "![](images/Avocado4.png){fig-align=\"center\"}\n",
        "\n",
        "## \n",
        "\n",
        "In technical terms, the partial autocorrelation function fits the following linear regression model\n",
        "\n",
        "$$\\hat{Y}_t = \\hat{\\beta}_1 Y_{t-1} + \\hat{\\beta}_2 Y_{t-2}$$ Where:\n",
        "\n",
        "-   $\\hat{Y}_{t}$ is the predicted response at the current time ($t$).\n",
        "-   $\\hat{\\beta}_1$ is the *direct effect* of $Y_{t-1}$ on predicting $Y_{t}$.\n",
        "-   $\\hat{\\beta}_2$ is the *direct effect* of $Y_{t-2}$ on predicting $Y_{t}$.\n",
        "\n",
        "The partial autocorrelation between $Y_t$ and $Y_{t-2}$ is equal to $\\hat{\\beta}_2$.\n",
        "\n",
        "## \n",
        "\n",
        "-   The partial autocorrelation function is visualized using a graph similar to that for autocorrelation.\n",
        "\n",
        "-   The vertical axis shows the differences (or *lags*) between the periods considered, and the horizontal axis shows the partial correlations between observations at different lags.\n",
        "\n",
        "In Python, we use the `plot_pacf` function from **statsmodels**.\n"
      ],
      "id": "4a3847e1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: false\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "plot_pacf(Amtrak_data['Ridership (in 000s)'], lags = 25)\n",
        "plt.xlabel(\"Lag\")\n",
        "plt.ylabel(\"Correlation\")\n",
        "plt.show()"
      ],
      "id": "99ab52b6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "</br>\n",
        "\n",
        "::::::: center\n",
        ":::::: columns\n",
        ":::: {.column width=\"50%\"}\n",
        "::: {style=\"font-size: 80%;\"}\n",
        "</br>\n",
        "\n",
        "-   The partial autocorrelation plot shows that the responses and those from one period ago have a correlation of around 0.45. *This is the same for the autocorrelation plot.*\n",
        "\n",
        "-   The partial autocorrelation plot shows that the responses and those from two periods ago have a correlation near 0.\n",
        ":::\n",
        "::::\n",
        "\n",
        "::: {.column width=\"50%\"}"
      ],
      "id": "38556596"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "plot_pacf(Amtrak_data['Ridership (in 000s)'], lags = 25)\n",
        "plt.xlabel(\"Lag\")\n",
        "plt.ylabel(\"Correlation\")\n",
        "plt.show()"
      ],
      "id": "3ee8b55f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "::::::\n",
        ":::::::\n",
        "\n",
        "# The ARIMA Model\n",
        "\n",
        "## Autoregressive models\n",
        "\n",
        "*Autoregressive models* are a type of linear regression model that directly incorporate the autocorrelation of the time series to predict the current response.\n",
        "\n",
        "Their main characteristic is that the predictors of the current value of the series are its past values.\n",
        "\n",
        "::: incremental\n",
        "-   An autoregressive model of order 2 has the mathematical form: $\\hat{Y}_t = \\hat{\\beta}_0 + \\hat{\\beta}_1 Y_{t-1} + \\hat{\\beta}_2 Y_{t-2}.$\n",
        "\n",
        "-   A model of order 3 looks like this: $\\hat{Y}_t = \\hat{\\beta}_0 + \\hat{\\beta}_1 Y_{t-1} + \\hat{\\beta}_2 Y_{t-2} + \\hat{\\beta}_3 Y_{t-3}.$\n",
        ":::\n",
        "\n",
        "## ARIMA models\n",
        "\n",
        "</br>\n",
        "\n",
        "A special class of autoregressive models are [***ARIMA***]{style=\"color:purple;\"} ([*Autoregressive Integrated Moving Average*]{style=\"color:purple;\"}).\n",
        "\n",
        ". . .\n",
        "\n",
        "An ARIMA model consists of three elements:\n",
        "\n",
        "::: incremental\n",
        "1.  Integrated operators (*integrated*).\n",
        "2.  Autoregressive terms (*autoregressive*).\n",
        "3.  Stochastic terms (*moving average*).\n",
        ":::\n",
        "\n",
        "## 1. Integrated or differentiated operators (I)\n",
        "\n",
        "</br>\n",
        "\n",
        "They create a new variable $Z_t$, which equals the difference between the current response and the delayed response by a number of periods or lags.\n",
        "\n",
        "There are three common levels of differentiation:\n",
        "\n",
        "-   Level 0: $Z_t = Y_t$.\n",
        "-   Level 1: $Z_t = Y_t - Y_{t-1}$.\n",
        "-   Level 2: $Z_t = (Y_t - Y_{t-1}) - (Y_{t-1} - Y_{t-2})$.\n",
        "\n",
        "## Example 2\n",
        "\n",
        "We consider the time series \"CanadianWorkHours.xlsx\" that contains the average hours worked by a certain group of workers over a certain range of years.\n"
      ],
      "id": "eaaf2f9e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "CanadianWorkHours = pd.read_excel('CanadianWorkHours.xlsx')\n",
        "CanadianWorkHours.head(4)"
      ],
      "id": "15ab70e9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Creating a train and a validation data\n",
        "\n",
        "</br>\n",
        "\n",
        "Recall that we would like to train the model on earlier time periods and test it on later ones. To this end, we make the split using the code below.\n"
      ],
      "id": "6f32a011"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: false\n",
        "#| fig-align: center\n",
        "#| code-fold: false\n",
        "\n",
        "# Define the split point\n",
        "split_ratio = 0.8  # 80% train, 20% test\n",
        "split_point = int(len(CanadianWorkHours) * split_ratio)\n",
        "\n",
        "# Split the data\n",
        "Canadian_train = CanadianWorkHours[:split_point]\n",
        "Canadian_validation = CanadianWorkHours[split_point:]"
      ],
      "id": "ddf3ea8c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We use 80% of the time series for training and the rest for validation.\n",
        "\n",
        "## Training data\n"
      ],
      "id": "6415104e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "#| code-fold: true\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "sns.lineplot(x='Year', y='Hours per Week', data = Canadian_train)\n",
        "plt.xlabel('Year')\n",
        "plt.ylabel('Hours per Week')\n",
        "plt.title('Hours per Week Over Time')\n",
        "plt.show()"
      ],
      "id": "842eea11",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "</br></br>\n",
        "\n",
        "In **statsmodels**, we apply the integration operator using the pre-loaded `diff()` function. The function's `k_diff` argument specifies the order or level of the operator.\n",
        "\n",
        "</br>\n",
        "\n",
        "First, let's use a level-1 operator.\n"
      ],
      "id": "6fd7e7e3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "Z_series_one = diff(Canadian_train['Hours per Week'], k_diff = 1)"
      ],
      "id": "09ab38e0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "The time series with a level-1 operator looks like this.\n"
      ],
      "id": "7ed1d3ce"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "#| code-fold: true\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "sns.lineplot(x=Canadian_train['Year'], y=Z_series_one)\n",
        "plt.xlabel('Year')\n",
        "plt.ylabel('Difference Level 1')\n",
        "plt.show()"
      ],
      "id": "d3d725f2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "A level-2 operator would work like this.\n"
      ],
      "id": "4b141f43"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "Z_series_two = diff(Canadian_train['Hours per Week'], k_diff = 2)"
      ],
      "id": "71f55d07",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "#| code-fold: true\n",
        "\n",
        "plt.figure(figsize=(9, 5))\n",
        "sns.lineplot(x=Canadian_train['Year'], y=Z_series_two)\n",
        "plt.xlabel('Year')\n",
        "plt.ylabel('Difference Level 2')\n",
        "plt.show()"
      ],
      "id": "3e01ec95",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "We see that the level 2 operator is more successful in removing the trend from the original time series.\n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"50%\"}"
      ],
      "id": "1eebacc1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=(6, 6))\n",
        "sns.lineplot(x=Canadian_train['Year'], y=Z_series_one)\n",
        "plt.xlabel('Year')\n",
        "plt.ylabel('Difference Level 1')\n",
        "plt.show()"
      ],
      "id": "5a03d34d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.column width=\"50%\"}"
      ],
      "id": "192706b7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=(6, 6))\n",
        "sns.lineplot(x=Canadian_train['Year'], y=Z_series_two)\n",
        "plt.xlabel('Year')\n",
        "plt.ylabel('Difference Level 2')\n",
        "plt.show()"
      ],
      "id": "153d456b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "## Comments\n",
        "\n",
        "</br></br>\n",
        "\n",
        "The differentiation operator [*de-trends*]{style=\"color:#4682B4;\"} the time series.\n",
        "\n",
        "-   The level 0 differentiation operator leaves the time series intact.\n",
        "-   The level 1 differentiation operator removes its linear trend.\n",
        "-   The level 2 differentiation operator removes its quadratic trend.\n",
        "\n",
        "## How do we determine the operator level?\n",
        "\n",
        "</br>\n",
        "\n",
        "Visualizing the time series and determining whether there is a linear or quadratic trend.\n",
        "\n",
        "If level 1 and level 2 operators yield similar results, we choose level 1 because it is simpler.\n",
        "\n",
        "[*Once this is done, we set our transformed variable* $Z_t$ as the new response variable!]{style=\"color:purple;\"}\n",
        "\n",
        "## 2. Autoregressive (AR) terms\n",
        "\n",
        "</br>\n",
        "\n",
        "Here we use autoregressive models, but with the new response variable $Z_t$.\n",
        "\n",
        "We can have different levels of order (or number of terms) in the autoregression model. For example:\n",
        "\n",
        "-   Order 1 model: $\\hat{Z}_t = \\hat{\\beta}_0 + \\hat{\\beta}_1 Z_{t-1}$.\n",
        "\n",
        "-   Order 2 model: $\\hat{Z}_t = \\hat{\\beta}_0 + \\hat{\\beta}_1 Z_{t-1} + \\hat{\\beta}_2 Z_{t-2}$.\n",
        "\n",
        "If necessary, we can exclude the constant coefficient $\\hat{\\beta}_0$ from the model.\n",
        "\n",
        "## How do we determine the number of terms?\n",
        "\n",
        "Using the partial autocorrelation function (PACF) of the differenced series.\n",
        "\n",
        "- A first-order autoregressive model has a PACF with a single peak at the first period difference (lag).\n",
        "\n",
        "- A second-order autoregressive model has a PACF with two peaks at the first lags.\n",
        "\n",
        "- In general, the lag at which the PACF cuts off from the confidence limits in the software is the indicated number of AR terms.\n",
        "\n",
        "## \n",
        "\n",
        "</br>\n"
      ],
      "id": "3459c60f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=(3, 3))\n",
        "plot_pacf(Z_series_two, lags = 10)\n",
        "plt.xlabel(\"Lag\")\n",
        "plt.ylabel(\"Correlation\")\n",
        "plt.show()"
      ],
      "id": "9700d624",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "Using the PACF, we conclude that an autoregressive term of order 2 will be sufficient to capture the relationships between the elements of the series.\n"
      ],
      "id": "4a43942d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=(3, 3))\n",
        "plot_pacf(Z_series_two, lags = 10)\n",
        "plt.xlabel(\"Lag\")\n",
        "plt.ylabel(\"Correlation\")\n",
        "plt.show()"
      ],
      "id": "e1f6f531",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 3. Stochastic Terms (Moving Averages, MA)\n",
        "\n",
        "Instead of using past values of the response variable, a moving average model uses stochastic terms to predict the current response. The model has different versions depending on the number of errors used to predict the response. For example:\n",
        "\n",
        "-   MA of order 1: $Z_t = \\theta_0 + \\theta_1 a_{t-1}$;\n",
        "-   MA of order 2: $Z_t = \\theta_0 + \\theta_1 a_{t-1} + \\theta_2 a_{t-2}$,\n",
        "\n",
        "where $\\theta_0$ is a constant and $a_t$ are terms from a white noise series (i.e., random terms).\n",
        "\n",
        "## How do I choose the order of the MAs?\n",
        "\n",
        "</br></br>\n",
        "\n",
        "Using the autocorrelation function (ACF) of the differenced series.\n",
        "\n",
        "- In general, the lag at which the ACF cuts off from the confidence limits in the software is the indicated number of MA terms.\n",
        "\n",
        "##\n",
        "\n",
        "[*Since there is no significant correlation for any lag above 0, we do not need any MA elements to model the series.*]{style=\"color:darkblue;\"}\n"
      ],
      "id": "27ed3e36"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=(3, 3))\n",
        "plot_acf(Z_series_two, lags = 10)\n",
        "plt.xlabel(\"Lag\")\n",
        "plt.ylabel(\"Correlation\")\n",
        "plt.show()"
      ],
      "id": "e3623a6f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## ARIMA\n",
        "\n",
        "</br>\n",
        "\n",
        "::: incremental\n",
        "1.  Define the response differentiation level and create $Z_t$.\n",
        "\n",
        "2.  Define the order of the AR model (e.g., order 2).\n",
        "\n",
        "3.  Define the order of the MA model (e.g., order 1).\n",
        ":::\n",
        "\n",
        ". . .\n",
        "\n",
        "::: center\n",
        "$$\\hat{Z}_t = \\hat{\\beta}_0 + \\hat{\\beta}_1 Z_{t-1} + \\hat{\\beta}_2 Z_{t-2} + \\theta_1 a_{t-1}$$\n",
        ":::\n",
        "\n",
        ". . .\n",
        "\n",
        "The ARIMA model coefficients are estimated using an advanced method that takes into account the dependencies between the time series responses.\n",
        "\n",
        "## ARIMA in Pyhon\n",
        "\n",
        "</br></br>\n",
        "\n",
        "To fit an ARIMA model, we use the `ARIMA()` function from **statsmodels**.\n",
        "\n",
        "The function has an important argument called `order`, which equals `(p,d,q)`, where\n",
        "\n",
        "-   `p` is the order of the autoregressive model.\n",
        "-   `d` is the level of the integration or differencing operator.\n",
        "-   `q` is the number of elements in the moving average.\n",
        "\n",
        "## \n",
        "\n",
        "</br>\n",
        "\n",
        "From our previous analysis of the training data for the Canadian workhours example, we conclude that:\n",
        "\n",
        "-   We must use a level-2 differencing operator to remove the quadratic trend from the series. Therefore, `d = 2`.\n",
        "\n",
        "-   One autoregressive term should be sufficient to capture the patterns in the time series. Therefore, `p = 2`.\n",
        "\n",
        "-   It is not necessary to have moving average terms. Therefore, `q = 0`.\n",
        "\n",
        "## \n",
        "\n",
        "</br></br>\n",
        "\n",
        "Once this is defined, we can train an ARIMA model using the training data with the following code:\n"
      ],
      "id": "02b1c9be"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: false\n",
        "#| fig-align: center\n",
        "\n",
        "Arima_Canadian = ARIMA(Canadian_train['Hours per Week'], \n",
        "                       order=(2, 2, 0))\n",
        "results_ARIMA_Canadian = Arima_Canadian.fit()"
      ],
      "id": "f8852dad",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Technically, `ARIMA()` defines the model and `.fit()` fits the model to the data using *maximum likelihood estimation*.\n",
        "\n",
        "## \n",
        "\n",
        "After fitting, we can get a summary of the model fit using the following code.\n"
      ],
      "id": "836d97ec"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "print(results_ARIMA_Canadian.summary())"
      ],
      "id": "9fb75801",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "**The next step in evaluating an ARIMA model is to study the model's residuals to ensure there is nothing else to explain in the model.**\n",
        "\n",
        "</br>\n",
        "\n",
        "However, since the ARIMA model has two AR terms, we must inspect the residuals starting from the third observation. We achieve this using the code below.\n"
      ],
      "id": "bdf5db21"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: false\n",
        "#| fig-align: center\n",
        "\n",
        "# Extract the residuals.\n",
        "ARIMA_residuals = results_ARIMA_Canadian.resid\n",
        "\n",
        "# Select residuals starting from observation 3 and onwards.\n",
        "ARIMA_residuals = ARIMA_residuals[2:]"
      ],
      "id": "8c5d9aa4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Time series of residuals\n"
      ],
      "id": "58e7fd93"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "#| code-fold: true\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "sns.lineplot(x=Canadian_train['Year'], y=ARIMA_residuals)\n",
        "plt.xlabel('Year')\n",
        "plt.ylabel('Residuals')\n",
        "plt.show()"
      ],
      "id": "b94cfc75",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Correlation plots\n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"50%\"}"
      ],
      "id": "cf1a8695"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "plot_acf(ARIMA_residuals, lags = 10)\n",
        "plt.xlabel(\"Lag\")\n",
        "plt.ylabel(\"Correlation\")\n",
        "plt.show()"
      ],
      "id": "6faf3bea",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.column width=\"50%\"}"
      ],
      "id": "2d737e6c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "plot_pacf(ARIMA_residuals, lags = 10)\n",
        "plt.xlabel(\"Lag\")\n",
        "plt.ylabel(\"Correlation\")\n",
        "plt.show()"
      ],
      "id": "bbe60f00",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "## \n",
        "\n",
        "</br></br></br>\n",
        "\n",
        "[**The three graphs show no obvious patterns or significant correlations between the residuals. Therefore, we say the model is good.**]{style=\"color:darkgreen;\"}\n",
        "\n",
        "## Forecast\n",
        "\n",
        "Once the model is validated, we make predictions for elements in the time series.\n",
        "\n",
        "</br>\n",
        "\n",
        "To predict the average number of hours worked in the next, say, 3 years, we use the `.forecast()` function. The `steps` argument indicates the number of steps in the future to make the predictions.\n"
      ],
      "id": "233fbc7a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "results_ARIMA_Canadian.forecast(steps = 3)"
      ],
      "id": "cd5efece",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Model evaluation using RMSE\n",
        "\n",
        "</br></br>\n",
        "\n",
        "- Instead of evaluating the ARIMA model using graphical analyses of the residuals, we can take a more *data-driven* approach and evaluate the model using the root mean squared error (RMSE).\n",
        "\n",
        "- To this end, we use the `mean_squared_error()` function with the validation responses and our predictions. We take the square root of the result to obtain the RMSE.\n",
        "\n",
        "## Validation data\n"
      ],
      "id": "bd2d856a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "Canadian_validation"
      ],
      "id": "50db3b3a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "</br>\n",
        "\n",
        "The validation data has 7 time periods that can be determined using the command below.\n"
      ],
      "id": "7e80ad50"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "len(Canadian_validation)"
      ],
      "id": "bc173c20",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "So, we must forecast 7 periods ahead using our ARIMA model.\n"
      ],
      "id": "09fdd087"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "forecast_Canadian = results_ARIMA_Canadian.forecast(steps = 7)\n",
        "forecast_Canadian"
      ],
      "id": "a4b1ef91",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "</br></br>\n",
        "\n",
        "Using the forecast and validation data, we compute the RMSE.\n"
      ],
      "id": "e19b3f16"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "mse = mean_squared_error(Canadian_validation[\"Hours per Week\"], \n",
        "                         forecast_Canadian)  \n",
        "print(round(mse**(1/2), 2))"
      ],
      "id": "3192a7c1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## *Naive* forecast\n",
        "\n",
        "To determine if the RMSE is high or small, we must compare it with a *naive* forecast that predicts the response $Y_t$ with the previous one $Y_{t-1}$. To build this forecast, we follow three steps. \n",
        "\n",
        "First, we shift the time series in the validation data by one position using the `.shit(1)` function.\n"
      ],
      "id": "c1d2b015"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "naive_forecast = Canadian_validation[\"Hours per Week\"].shift(1)\n",
        "naive_forecast.head()"
      ],
      "id": "b9cfed9b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##\n",
        "\n",
        "Second, we notice that the first element of the shifted series is missing or not available (`NaN`). We thus fill it in with the last observation in our training dataset, which we can obtain using the `.iloc()` function.\n"
      ],
      "id": "ae2a0e6b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "Canadian_train.iloc[-1]"
      ],
      "id": "7e03320b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</br>\n",
        "\n",
        "Third, we input 35.9 as the first record in `naive_forecast`. The first record of the object is indexed by a 28.\n"
      ],
      "id": "108ad0a5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "naive_forecast[28] = 35.9"
      ],
      "id": "c31dd9ac",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##\n",
        "\n",
        "Our naive forecast of the time series in the validation data would be these one:\n"
      ],
      "id": "eadceb66"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "# Combine into a DataFrame\n",
        "df_combined = pd.concat(\n",
        "    [naive_forecast, Canadian_validation[\"Hours per Week\"]],\n",
        "    axis=1\n",
        ")\n",
        "\n",
        "# Rename columns\n",
        "df_combined.columns = [\"Naive Forecast\", \"Hours per week\"]\n",
        "df_combined"
      ],
      "id": "f5c8c77f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "</br>\n",
        "\n",
        "The RMSE of the naive forecast is calculated below.\n"
      ],
      "id": "17218bcc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "naive_rmse = mean_squared_error(Canadian_validation[\"Hours per Week\"], \n",
        "                                naive_forecast)\n",
        "print(round(naive_rmse**(1/2), 2))"
      ],
      "id": "6c09402b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</br>\n",
        "\n",
        "We conclude that predicting with the previous response is a better approach than predicting with an ARIMA model. This is because the RMSE for the naive forecast is 0.31, and that of the ARIMA model is 0.75.\n",
        "\n",
        "## \n",
        "\n",
        "</br>\n"
      ],
      "id": "039bf6ae"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "# Build a DataFrame for the forecast with corresponding years\n",
        "forecast_years = Canadian_validation['Year'].values\n",
        "forecast_df = pd.DataFrame({\n",
        "    'Year': forecast_years,\n",
        "    'Hours per Week': forecast_Canadian,\n",
        "    'Type': 'Forecast'\n",
        "})\n",
        "\n",
        "# Add 'Type' column to training and validation data\n",
        "Canadian_train_plot = Canadian_train.copy()\n",
        "Canadian_train_plot['Type'] = 'Train'\n",
        "\n",
        "Canadian_validation_plot = Canadian_validation.copy()\n",
        "Canadian_validation_plot['Type'] = 'Validation'\n",
        "\n",
        "# Concatenate everything\n",
        "plot_df = pd.concat([Canadian_train_plot, Canadian_validation_plot, forecast_df])\n",
        "\n",
        "# Plot using seaborn\n",
        "plt.figure(figsize=(10, 6))\n",
        "sns.lineplot(data=plot_df, x='Year', y='Hours per Week', hue='Type', style='Type', markers=False)\n",
        "plt.xlabel('Year')\n",
        "plt.ylabel('Hours per Week')\n",
        "plt.title('Actual and Forecasted Hours per Week Over Time')\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "cc681ad8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# The SARIMA Model\n",
        "\n",
        "## Seasonality\n",
        "\n",
        "</br></br>\n",
        "\n",
        "-   Seasonality consists of repetitive or cyclical behavior that occurs with a constant frequency.\n",
        "\n",
        "-   It can be identified from the series graph or using the ACF and PACF.\n",
        "\n",
        "-   To do this, we must have removed the trend.\n",
        "\n",
        "## Example 3\n",
        "\n",
        "We use the Airline data containing the number of passengers of an international airline per month between 1949 and 1960.\n"
      ],
      "id": "14123b5b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "#| code-fold: false\n",
        "\n",
        "Airline_data = pd.read_excel(\"Airline.xlsx\")\n",
        "Airline_data.head()"
      ],
      "id": "47252a75",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Create training and validation data\n",
        "\n",
        "</br></br>\n",
        "\n",
        "We use 80% of the time series for training and the rest for validation.\n"
      ],
      "id": "0782013d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: false\n",
        "#| fig-align: center\n",
        "#| code-fold: false\n",
        "\n",
        "# Define the split point\n",
        "split_ratio = 0.8  # 80% train, 20% test\n",
        "split_point = int(len(Airline_data) * split_ratio)\n",
        "\n",
        "# Split the data\n",
        "Airline_train = Airline_data[:split_point]\n",
        "Airline_validation = Airline_data[split_point:]"
      ],
      "id": "301a7ba8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Training data\n"
      ],
      "id": "cfae3336"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "#| code-fold: true\n",
        "\n",
        "plt.figure(figsize=(8, 5))\n",
        "sns.lineplot(x='T', y='Number of passengers', data = Airline_train)\n",
        "plt.xlabel('T')\n",
        "plt.ylabel('Number of passengers')\n",
        "plt.xticks(rotation=45)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "503db99a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "First, let's use a level-1 operator.\n"
      ],
      "id": "50755464"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "Z_series_one = diff(Airline_train['Number of passengers'], k_diff = 1)"
      ],
      "id": "9afed662",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "#| code-fold: true\n",
        "\n",
        "plt.figure(figsize=(8, 5))\n",
        "sns.lineplot(x=Airline_train['Number of passengers'], y=Z_series_one)\n",
        "plt.xlabel('T')\n",
        "plt.ylabel('Difference Level 1')\n",
        "plt.show()"
      ],
      "id": "eac8461c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Autocorrelation plots\n",
        "\n",
        "</br>\n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"50%\"}"
      ],
      "id": "011819e0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=(3, 3))\n",
        "plot_acf(Z_series_one, lags = 13)\n",
        "plt.xlabel(\"Lag\")\n",
        "plt.ylabel(\"Correlation\")\n",
        "plt.show()"
      ],
      "id": "7d6303c2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.column width=\"50%\"}"
      ],
      "id": "131981c2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=(3, 3))\n",
        "plot_pacf(Z_series_one, lags = 13)\n",
        "plt.xlabel(\"Lag\")\n",
        "plt.ylabel(\"Correlation\")\n",
        "plt.show()"
      ],
      "id": "15936c0b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "## SARIMA model\n",
        "\n",
        "The [S]{style=\"color:orange;\"}ARIMA ([*Seasonal*]{style=\"color:orange;\"} Autoregressive Integrated Moving Average) model is an extension of the ARIMA model for modeling seasonality patterns.\n",
        "\n",
        "The SARIMA model has three additional elements for modeling seasonality in time series.\n",
        "\n",
        "1.  Differenced or integrated operators (*integrated*) for seasonality.\n",
        "2.  Autoregressive terms (*autoregressive*) for seasonality.\n",
        "3.  Stochastic terms or moving averages (*moving average*) for seasonality.\n",
        "\n",
        "## Notation\n",
        "\n",
        "</br>\n",
        "\n",
        "Seasonality in a time series is a regular pattern of change that repeats over [$S$ time periods]{style=\"color:orange;\"}, where $S$ defines the number of time periods until the pattern repeats again.\n",
        "\n",
        "For example, there is seasonality in monthly data, where high values always tend to occur in some particular months and low values always tend to occur in other particular months.\n",
        "\n",
        "In this case, $S=12$ (months per year) is the length of periodic seasonal behavior. For quarterly data, $S=4$ time periods per year.\n",
        "\n",
        "## Seasonal differentiation\n",
        "\n",
        "</br>\n",
        "\n",
        "This is the difference between a response and a response with a lag that is a multiple of $S$.\n",
        "\n",
        "For example, with monthly data $S=12$,\n",
        "\n",
        "-   A level 1 seasonal difference is $Y_{t} - Y_{t-12}$.\n",
        "-   A level 2 seasonal difference is $(Y_{t-12}) - (Y_{t-12} - Y_{t-24})$.\n",
        "\n",
        "Seasonal differencing eliminates the seasonal trend and can also eliminate a type of nonstationarity caused by a seasonal random walk.\n",
        "\n",
        "## Seasonal AR and MA Terms\n",
        "\n",
        "In SARIMA, the seasonal AR and MA component terms predict the current response ($Y_t$) using responses and errors at times with lags that are multiples of $S$.\n",
        "\n",
        "For example, with monthly data $S = 12$,\n",
        "\n",
        "::: {style=\"font-size: 85%;\"}\n",
        "-   The first-order seasonal AR model would use $Y_{t-12}$ to predict $Y_{t}$.\n",
        "-   The second-order seasonal AR model would use $Y_{t-12}$ and $Y_{t-24}$ to predict $Y_{t}$.\n",
        "-   The first-order seasonal MA model would use the stochastic term $a_{t-12}$ as a predictor.\n",
        "-   The second-order seasonal MA model would use the stochastic terms $a_{t-12}$ and $a_{t-24}$ as predictors.\n",
        ":::\n",
        "\n",
        "## \n",
        "\n",
        "</br></br>\n",
        "\n",
        "To fit the SARIMA model, we use the `ARIMA()` function from **statsmodels**, but with an additional argument, `seasonal_order=(0, 0, 0, 0)`.\n",
        "\n",
        "</br>\n",
        "\n",
        "This is the order (P, D, Q, s) of the seasonal component of the model for the autoregressive parameters, differencing operator levels, moving average parameters, and periodicity.\n",
        "\n",
        "::: notes\n",
        "Recall that the function has the argument `order = (p, d, q)` where `p` is the order of the autoregressive model, `d` is the differencing operator level, and `q` is the number of elements in the moving average.\n",
        "\n",
        "These arguments capture the detailed information of the time series, while seasonal_order captures the patterns given by seasonality.\n",
        ":::\n",
        "\n",
        "## \n",
        "\n",
        "</br></br></br>\n",
        "\n",
        "Let's fit a SARIMA model.\n"
      ],
      "id": "2594a7ab"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "#| code-fold: false\n",
        "\n",
        "SARIMA_model = ARIMA(Airline_train['Number of passengers'], order=(1, 2, 1), \n",
        "                      seasonal_order=(1, 1, 0, 12))\n",
        "SARIMA_Airline = SARIMA_model.fit()"
      ],
      "id": "415d03fb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Summary of fit\n"
      ],
      "id": "afabbaa1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "#| code-fold: false\n",
        "\n",
        "print(SARIMA_Airline.summary())"
      ],
      "id": "286e5fcd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Residual analysis\n",
        "\n",
        "We can have a graphical evaluation of the model's performance using a residual analysis.\n"
      ],
      "id": "3c69461c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "#| code-fold: false\n",
        "\n",
        "SARIMA_residuals = SARIMA_Airline.resid\n",
        "SARIMA_residuals = SARIMA_residuals[2:]"
      ],
      "id": "ebbe3bee",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "#| code-fold: true\n",
        "\n",
        "plt.figure(figsize=(8, 3.5))\n",
        "sns.lineplot(x=Airline_train['T'], y=SARIMA_residuals)\n",
        "plt.xlabel('Year')\n",
        "plt.ylabel('Residuals')\n",
        "plt.show()"
      ],
      "id": "3b245832",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "</br>\n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"50%\"}"
      ],
      "id": "931ad931"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=(6, 6))\n",
        "plot_acf(SARIMA_residuals, lags = 24)\n",
        "plt.xlabel(\"Lag\")\n",
        "plt.ylabel(\"Correlation\")\n",
        "plt.show()"
      ],
      "id": "855284f1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.column width=\"50%\"}"
      ],
      "id": "4e0221e3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "plt.figure(figsize=(6, 6))\n",
        "plot_pacf(SARIMA_residuals, lags = 24)\n",
        "plt.xlabel(\"Lag\")\n",
        "plt.ylabel(\"Correlation\")\n",
        "plt.show()"
      ],
      "id": "d8a9068b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "## Validation\n",
        "\n",
        "The validation data has 29 time periods that can be determined using the command below.\n"
      ],
      "id": "f0d738b8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "len(Airline_validation)"
      ],
      "id": "d2360232",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</br>\n",
        "\n",
        "So, we must forecast 7 periods ahead using our SARIMA model.\n"
      ],
      "id": "97a838a4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "forecast_Airline = SARIMA_Airline.forecast(steps = 29)\n",
        "forecast_Airline.head(3)"
      ],
      "id": "97ecbebf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "</br></br>\n",
        "\n",
        "Using the forecast and validation data, we compute the RMSE.\n"
      ],
      "id": "004c336d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "mse = mean_squared_error(Airline_validation[\"Number of passengers\"], \n",
        "                        forecast_Airline)  \n",
        "print(round(mse**(1/2), 2))"
      ],
      "id": "21b5eb62",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Comparison with a naive forecast\n",
        "\n",
        "</br></br>\n",
        "\n",
        "Now, we build a naive forecast to study the performance of our SARIMA model. To this end, we shift the validation data by one period using the code below.\n"
      ],
      "id": "975c1e6d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "naive_forecast = Airline_validation[\"Number of passengers\"].shift(1)\n",
        "naive_forecast.head()"
      ],
      "id": "dfd33d75",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##\n",
        "\n",
        "Next, we determine the last element of the training data.\n"
      ],
      "id": "9f507302"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "Airline_train.iloc[-1]"
      ],
      "id": "23270002",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Finally, we assemble our naive forecast by replacing the first entry of `naive_forecast` with the last entry of the response in the training dataset.\n"
      ],
      "id": "7c4d9baf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "naive_forecast[115] = 491\n",
        "naive_forecast.head()"
      ],
      "id": "bba5f943",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "</br></br>\n",
        "\n",
        "Let's calculate the RMSE of the naive forecast.\n"
      ],
      "id": "b401491c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "naive_rmse = mean_squared_error(Airline_validation[\"Number of passengers\"], naive_forecast)\n",
        "print(round(naive_rmse**(1/2), 2))"
      ],
      "id": "f5331cf4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The RMSE of the SARIMA model is 26.38, while that of the naive forecast is 54.15. Therefore, the SARIMA model is better than the naive forecast.\n",
        "\n",
        "## \n",
        "\n",
        "</br>\n"
      ],
      "id": "ba13d1c6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "# Build a DataFrame for the forecast with corresponding years\n",
        "forecast_years = Airline_validation['T'].values\n",
        "forecast_df = pd.DataFrame({\n",
        "    'T': forecast_years,\n",
        "    'Number of passengers': forecast_Airline,\n",
        "    'Type': 'Forecast'\n",
        "})\n",
        "\n",
        "# Add 'Type' column to training and validation data\n",
        "Airline_train_plot = Airline_train.copy()\n",
        "Airline_train_plot['Type'] = 'Train'\n",
        "\n",
        "Airline_validation_plot = Airline_validation.copy()\n",
        "Airline_validation_plot['Type'] = 'Validation'\n",
        "\n",
        "# Concatenate everything\n",
        "plot_df = pd.concat([Airline_train_plot, Airline_validation_plot, forecast_df])\n",
        "\n",
        "# Plot using seaborn\n",
        "plt.figure(figsize=(10, 6))\n",
        "sns.lineplot(data=plot_df, x='T', y='Number of passengers', hue='Type', style='Type', markers=False)\n",
        "plt.xlabel('Year')\n",
        "plt.ylabel('Hours per Week')\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "40e8e6a4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# [Return to main page](https://alanrvazquez.github.io/TEC-IN2004B/)"
      ],
      "id": "737c65d8"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}