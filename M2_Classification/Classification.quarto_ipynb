{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Classification Methods\"\n",
        "subtitle: \"IN2004B: Generation of Value with Data Analytics\"\n",
        "author: \n",
        "  - name: Alan R. Vazquez\n",
        "    affiliations:\n",
        "      - name: Department of Industrial Engineering\n",
        "format: \n",
        "  revealjs:\n",
        "    chalkboard: false\n",
        "    multiplex: false\n",
        "    footer: \"Tecnologico de Monterrey\"\n",
        "    logo: IN1002b_logo.png\n",
        "    css: style.css\n",
        "    slide-number: True\n",
        "    html-math-method: mathjax\n",
        "editor: visual\n",
        "jupyter: python3\n",
        "---\n",
        "\n",
        "\n",
        "## Agenda\n",
        "\n",
        "</br>\n",
        "\n",
        "1.  Introducción\n",
        "2.  Classification and Regression Trees (CART)\n",
        "3.  Métricas de Algoritmos de Clasificación\n",
        "4.  *K* vecinos cercanos\n",
        "\n",
        "# Introducción\n",
        "\n",
        "## Load the libraries\n",
        "\n",
        "Before we start, let's import the data science libraries into Python.\n"
      ],
      "id": "1c7b9798"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: false\n",
        "\n",
        "# Importing necessary libraries\n",
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "import statsmodels.api as sm\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, accuracy_score"
      ],
      "id": "da99c986",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Here, we will introduce the functions `confusion_matrix()`, `ConfusionMatrixDisplay()` and `accuracy_score()` to evaluate the performance of a logistic regression classifier.\n",
        "\n",
        "## Problemas principales de cienca de datos\n",
        "\n",
        "[**Problemas de regresión**]{style=\"color:green;\"}. La respuesta es numérica. Por ejemplo, los ingresos de una persona, el valor de una casa, la presión arterial del paciente.\n",
        "\n",
        "[**Problemas de clasificación**]{style=\"color:blue;\"}. La respuesta es categórica e involucra K categorías diferentes. Por ejemplo, la marca de un producto adquirido (A, B, C) o si una persona incumple una deuda (sí o no).\n",
        "\n",
        "Los predictores pueden ser numéricos o categóricos.\n",
        "\n",
        "## \n",
        "\n",
        "</br>\n",
        "\n",
        "[Respuesta]{style=\"text-decoration: underline;\"}:\n",
        "\n",
        "::: incremental\n",
        "-   $Y$ es una [**variable categórica**]{style=\"color:darkgreen;\"} que toma [**2 categorías**]{style=\"color:darkgreen;\"} o [**clases**]{style=\"color:darkgreen;\"}.\n",
        "\n",
        "-   Por ejemplo, $Y$ puede tomar [0]{style=\"color:darkgreen;\"} o [1]{style=\"color:darkgreen;\"}, [A]{style=\"color:darkgreen;\"} o [B]{style=\"color:darkgreen;\"}, [no]{style=\"color:darkgreen;\"} o [sí]{style=\"color:darkgreen;\"}, [spam]{style=\"color:darkgreen;\"} o [no spam]{style=\"color:darkgreen;\"}.\n",
        "\n",
        "Cuando las clases son cadenas, se suele codificarlas como 0 y 1.\n",
        "\n",
        "La **clase de destino** es aquella para la que $Y = 1$. La **clase de referencia** es aquella para la que $Y = 0$.\n",
        ":::\n",
        "\n",
        "## Algoritmos de Clasificación\n",
        "\n",
        "Los algoritmos de clasificación usan los valores de los predictores [para predecir la clase]{style=\"color:lightblue;\"} de la respuesta (objetivo o referencia).\n",
        "\n",
        "Es decir, para un registro no visto, usan los valores de los predictores para predecir si el registro pertenece a la clase objetivo o no.\n",
        "\n",
        "Técnicamente, predicen la [probabilidad]{style=\"color:purple;\"} de que el registro pertenece a la clase objetivo.\n",
        "\n",
        "## Ejemplo 1\n",
        "\n",
        "Considere un filtro de correo no deseado donde $Y$ es el tipo de correo.\n",
        "\n",
        "-   La clase de destino es spam. En este caso, $Y=1$.\n",
        "-   La clase de referencia no es spam. En este caso, $Y=0$.\n",
        "\n",
        ". . .\n",
        "\n",
        "![](images/spam.png){fig-align=\"center\" width=\"556\" height=\"178\"}\n",
        "\n",
        ". . .\n",
        "\n",
        "Ambos correos se clasificarían como spam. Sin embargo, tendríamos mayor confianza en nuestra clasificación para el segundo correo.\n",
        "\n",
        "# Classification and Regression Trees (CART)\n",
        "\n",
        "## Arbol de Decisión\n",
        "\n",
        "Es un algoritmo de aprendizaje supervisado que predice o clasifica observaciones usando una estructura de arbol jerarquica.\n",
        "\n",
        "-   Sencillo y útil para interpretaciones.\n",
        "\n",
        "-   Puede manejar predictores y respuestas numéricas y categóricas.\n",
        "\n",
        "-   Computacionalmente eficiente.\n",
        "\n",
        "-   Técnica no paramétrica.\n",
        "\n",
        "## Ejemplo 2: Identificar Billetes Falsos\n",
        "\n",
        "</br>\n",
        "\n",
        "![](images/clipboard-270396609.png)\n",
        "\n",
        "Conjunto de datos\n",
        "\n",
        "Los datos se encuentran en el archivo \"banknotes.xlsx\".\n"
      ],
      "id": "062d2b2a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "\n",
        "bank_data = pd.read_excel(\"banknotes.xlsx\")\n",
        "# Set response variable as categorical.\n",
        "bank_data['Status'] = pd.Categorical(bank_data['Status'])\n",
        "bank_data.head()"
      ],
      "id": "4b446227",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Generar datos de entrenamiento\n",
        "\n",
        "Dividimos el conjunto de datos actual en dos conjuntos de datos: de entrenamiento y de validación. Para ello, utilizamos la función `train_test_split()` de **scikit-learn**.\n"
      ],
      "id": "93230197"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "\n",
        "# Set full matrix of predictors.\n",
        "X_full = bank_data.drop(columns = ['Status'])\n",
        "\n",
        "# Set full matrix of responses.\n",
        "Y_full = bank_data['Status']\n",
        "\n",
        "# Split the dataset.\n",
        "X_train, X_val, Y_train, Y_val = train_test_split(X_full, Y_full, \n",
        "                                                    test_size=0.3)"
      ],
      "id": "43f1c0cd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "El parámetro `test_size` establece la parte del conjunto de datos que irá al conjunto de validación.\n",
        "\n",
        "## \n",
        "\n",
        "</br>\n",
        "\n",
        "-   La función realiza una partición inteligente de los datos utilizando la distribución *empírica* de la respuesta.\n",
        "\n",
        "-   Técnicamente, divide los datos para que la distribución de la respuesta en los conjuntos de entrenamiento y validación sea similar.\n",
        "\n",
        "-   Normalmente, la proporción del conjunto de datos que se destina al conjunto de prueba es del 20 % o 30 %.\n",
        "\n",
        "-   Más adelante, utilizaremos el [**conjunto de datos de validación**]{style=\"color:orange;\"} para evaluar el rendimiento de clasificación del modelo de regresión logística estimado para clasificar datos no observados.\n",
        "\n",
        "## Idea básica de un árbol de decisión\n",
        "\n",
        "Estratificar o segmentar el espacio predictor en varias regiones más simples.\n",
        "\n",
        "![](images/Screenshot%202025-07-28%20at%2011.47.35%20a.m..png){fig-align=\"center\"}\n",
        "\n",
        "## \n",
        "\n",
        "![](images/Modulo%202%20-%20Algoritmos%20de%20Clasificacion.012.jpeg){fig-align=\"center\"}\n",
        "\n",
        "## \n",
        "\n",
        "![](images/Modulo%202%20-%20Algoritmos%20de%20Clasificacion.013.jpeg){fig-align=\"center\"}\n",
        "\n",
        "## ¿Cómo se construye un árbol de decisión?\n",
        "\n",
        "La construcción de árboles de decisión implica dos procedimientos principales.\n",
        "\n",
        "1.  [Crece un árbol grande.]{style=\"color:lightblue;\"}\n",
        "\n",
        "2.  [Poda el árbol para evitar un ajuste excesivo.]{style=\"color:lightblue;\"}\n",
        "\n",
        "Después de construir un “buen” árbol, podemos predecir nuevas observaciones que no se encuentran en el conjunto de datos que usamos para construirlo.\n",
        "\n",
        "## ¿Cómo crecemos un arbol?\n",
        "\n",
        "**Usando el algoritmo CART!**\n",
        "\n",
        "El algoritmo utiliza una estrategia de división binaria recursiva que construye el árbol utilizando un enfoque codicioso de arriba hacia abajo.\n",
        "\n",
        "Básicamente, en un nodo determinado, considera todas las variables y todas las posibles divisiones de esa variable. Luego, para la clasificación, elige la mejor variable y la divide que **minimiza** la llamada [***impureza***]{style=\"color:purple;\"}.\n",
        "\n",
        "## \n",
        "\n",
        "![](images/Modulo%202%20-%20Algoritmos%20de%20Clasificacion.016.jpeg){fig-align=\"center\"}\n",
        "\n",
        "## \n",
        "\n",
        "![](images/Modulo%202%20-%20Algoritmos%20de%20Clasificacion.017.jpeg){fig-align=\"center\"}\n",
        "\n",
        "## \n",
        "\n",
        "![](images/Modulo%202%20-%20Algoritmos%20de%20Clasificacion.018.jpeg){fig-align=\"center\"}\n",
        "\n",
        "## \n",
        "\n",
        "![](images/Modulo%202%20-%20Algoritmos%20de%20Clasificacion.019.jpeg)\n",
        "\n",
        "## \n",
        "\n",
        "![](images/Modulo%202%20-%20Algoritmos%20de%20Clasificacion.020.jpeg){fig-align=\"center\"}\n",
        "\n",
        "## \n",
        "\n",
        "![](images/Modulo%202%20-%20Algoritmos%20de%20Clasificacion.021.jpeg){fig-align=\"center\"}\n",
        "\n",
        "## \n",
        "\n",
        "![](images/Modulo%202%20-%20Algoritmos%20de%20Clasificacion.022.jpeg){fig-align=\"center\"}\n",
        "\n",
        "## \n",
        "\n",
        "![](images/Modulo%202%20-%20Algoritmos%20de%20Clasificacion.023.jpeg){fig-align=\"center\"}\n",
        "\n",
        "## \n",
        "\n",
        "![](images/Modulo%202%20-%20Algoritmos%20de%20Clasificacion.024.jpeg){fig-align=\"center\"}\n",
        "\n",
        "## \n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"40%\"}\n",
        "Repetimos el proceso de partición hasta que los nodos terminales tengan no menos de 5 observaciones\n",
        ":::\n",
        "\n",
        "::: {.column width=\"60%\"}\n",
        "![](images/Modulo%202%20-%20Algoritmos%20de%20Clasificacion.025.jpeg){fig-align=\"center\"}\n",
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "## ¿Qué es impureza?\n",
        "\n",
        "La impureza del nodo se refiere a la homogeneidad de las clases de respuesta en ese nodo.\n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"50%\"}\n",
        "![](images/Impurity1.png){fig-align=\"center\"}\n",
        ":::\n",
        "\n",
        "::: {.column width=\"50%\"}\n",
        "![](images/Impurity2.png){fig-align=\"center\"}\n",
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "[*El algorítmo CART minimiza la impureza entre los nodos del arbol.*]{style=\"color:darkgray;\"}\n",
        "\n",
        "# ¿Cómo medimos la impureza?\n",
        "\n",
        ":::::: center\n",
        "::::: columns\n",
        "::: {.column width=\"40%\"}\n",
        "Hay tres métricas diferentes para la impureza:\n",
        "\n",
        "-   Riesgo de clasificación errónea\n",
        "\n",
        "-   Entropía cruzada\n",
        "\n",
        "-   Índice de impurezas de Gini\n",
        ":::\n",
        "\n",
        "::: {.column width=\"60%\"}\n",
        "![](images/Metrics1.png){fig-align=\"center\"} ![](images/Metrics2.png){fig-align=\"center\"} [Proportion of elements in a class]{.smallcaps}\n",
        ":::\n",
        ":::::\n",
        "::::::\n",
        "\n",
        "## Podando el Arbol\n",
        "\n",
        "Para evitar un ajuste excesivo, podamos algunas de las ramas del árbol. Más específicamente, colapsamos dos nodos internos (no terminales).\n",
        "\n",
        "![](images/clipboard-1949573140.png)\n",
        "\n",
        "## \n",
        "\n",
        "![](images/Modulo%202%20-%20Algoritmos%20de%20Clasificacion.029.jpeg){fig-align=\"center\"}\n",
        "\n",
        "## \n",
        "\n",
        "Para podar un arbol usamos un algoritmo avanzado para medir la contribucón de las ramas del arbol.\n",
        "\n",
        "El algoritmo tiene un parametro de ajuste llamado $\\alpha$, que **pone mayor peso en el numero de nodos del arbol** (o tamaño):\n",
        "\n",
        "-   Valores grandes de $\\alpha$ resultan en arboles pequeños con pocos nodos.\n",
        "\n",
        "-   Valores pequeños de $\\alpha$ resultan en arboles grandes con muchos nodos.\n",
        "\n",
        "## Detalles de implementación\n",
        "\n",
        "-   Predictores categóricos con niveles desordenados $\\{A, B, C\\}$. Ordenamos los niveles de una manera específica (funciona para problemas binarios y de regresión).\n",
        "\n",
        "-   Predictores con valores faltantes. Para predictores cuantitativos, usamos imputación múltiple. Para predictores categóricos, creamos un nuevo nivel \"NA\".\n",
        "\n",
        "-   Divisiones terciarias o cuartarias. No hay mucha mejora.\n",
        "\n",
        "-   Divisiones en diagonal (usando una combinación lineal para la partición). Pueden conducir a una mejora, pero perjudican la interpretabilidad.\n",
        "\n",
        "# Ejemplo en Python\n",
        "\n",
        "Los datos “AdultReduced.jmp” provienen del Repositorio de Aprendizaje Automático de la UCI y se derivan de registros del censo de USA.\n",
        "\n",
        "En estos datos, el objetivo es predecir si los ingresos de una persona eran grandes (definidos en 1994 como más de 50.000 dólares) o pequeños.\n",
        "\n",
        "Los predictores incluyen nivel educativo, tipo de trabajo (por ejemplo, nunca trabajó y gobierno local), ganancias/pérdidas de capital, horas de trabajo por semana, país de origen, etc.\n",
        "\n",
        "Los datos tienen 7,508 registros.\n",
        "\n",
        "## Desventaja de los Arboles de Decisión\n",
        "\n",
        "-   Los árboles de decisión tienen una gran variación. Un pequeño cambio en los datos de entrenamiento puede dar lugar a un árbol muy diferente.\n",
        "\n",
        "-   Tiene problemas para identificar estructuras de datos simples.\n",
        "\n",
        "![](images/clipboard-3265772983.png)\n",
        "\n",
        "# Métricas de Algoritmos de Clasificación\n",
        "\n",
        "## Evaluación\n",
        "\n",
        "</br>\n",
        "\n",
        "Evaluamos un clasificador de regresión logística clasificando las observaciones que no se utilizaron para el entrenamiento ni para su estimación.\n",
        "\n",
        "Es decir, utilizamos el clasificador para predecir las categorías del conjunto de datos de prueba utilizando únicamente los valores predictores de este conjunto.\n",
        "\n",
        "En Python, usamos los comandos:\n"
      ],
      "id": "893d39d4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "\n",
        "# Remove problematic predictor from the test set.\n",
        "#X_val = X_val.drop(columns = ['Right'])\n",
        "\n",
        "# Add constant to the predictor matrix from the test set.\n",
        "#X_val = sm.add_constant(X_val)\n",
        "\n",
        "# Predict probabilities.\n",
        "#predicted_probability = logit_model.predict(X_val)"
      ],
      "id": "bbfd8bd5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "La función `predict()` genera [**probabilidades**]{style=\"color:brown;\"} en lugar de las clases reales.\n"
      ],
      "id": "7fa9ac1f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "\n",
        "#predicted_probability.head()"
      ],
      "id": "0a3df5e0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Estas son las probabilidades de que un billete sea \"falso\" según sus características (valores de los predictores).\n",
        "\n",
        "Para convertir las probabilidades en clases reales, las redondeamos:\n"
      ],
      "id": "b0b8fa5e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#predicted_classes = round(predicted_probability).astype('int')"
      ],
      "id": "69cb90d1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n"
      ],
      "id": "1f980f64"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#predicted_classes.head()"
      ],
      "id": "85775bc1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   Las observaciones con probabilidades superiores a 0,5 se clasifican como \"falsas\".\n",
        "-   Las observaciones con probabilidades inferiores a 0,5 se clasifican como \"genuinas\".\n",
        "\n",
        "Ahora, comparamos las predicciones con las categorías reales en el [**conjunto de datos de validación**]{style=\"color:orange;\"}. [Un buen modelo de regresión logística presenta una buena concordancia entre sus predicciones y las categorías reales.]{style=\"color:darkblue;\"}\n",
        "\n",
        "## Matriz de confusión\n",
        "\n",
        "-   Tabla utilizada para evaluar el rendimiento de un clasificador.\n",
        "\n",
        "-   Compara los valores reales con los valores predichos de un clasificador.\n",
        "\n",
        "-   Útil para problemas de clasificación binaria y multiclase.\n",
        "\n",
        "![](images/confusion_matrix.png){fig-align=\"center\"}\n",
        "\n",
        "## En Python\n",
        "\n",
        "</br>\n",
        "\n",
        "Calculamos la matriz de confusión utilizando la función homónima **scikit-learn**.\n"
      ],
      "id": "02aa0a6c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "\n",
        "# Create dummy variables for test set.\n",
        "#Y_dummies = pd.get_dummies(Y_val, dtype = 'int')\n",
        "\n",
        "# Select target variable from test set.\n",
        "#Y_target_test = Y_dummies['counterfeit']\n",
        "\n",
        "# Compute confusion matrix.\n",
        "#cm = confusion_matrix(Y_target_test, predicted_classes)\n",
        "\n",
        "# Show confusion matrix.\n",
        "#print(cm)"
      ],
      "id": "19c1f524",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "Podemos visualizar la matriz de confusión utilizando la función `ConfusionMatrixDisplay()`.\n"
      ],
      "id": "0f5f2dcb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "#ConfusionMatrixDisplay(cm).plot()"
      ],
      "id": "8761dd50",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Precisión\n",
        "\n",
        "Una métrica simple para resumir la información de la matriz de confusión es la **precisión**. Es la proporción de clasificaciones correctas para ambas clases, del total de clasificaciones realizadas.\n",
        "\n",
        "En Python, calculamos la precisión mediante la función `accuracy_score()` de **scikit-learn**.\n"
      ],
      "id": "04a581a4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "\n",
        "#accuracy = accuracy_score(Y_target_test, predicted_classes)\n",
        "#print( round(accuracy, 2) )"
      ],
      "id": "11455efa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</br>\n",
        "\n",
        "Cuanto mayor sea la precisión, mejor será el rendimiento del clasificador.\n",
        "\n",
        "## Observaciones\n",
        "\n",
        "</br>\n",
        "\n",
        "-   La precisión es fácil de calcular e interpretar.\n",
        "\n",
        "-   Funciona bien cuando el conjunto de datos tiene una distribución de clases equilibrada (es decir, casos 1 y 0 aproximadamente iguales).\n",
        "\n",
        "-   Sin embargo, hay situaciones en las que identificar la clase objetivo es más importante que la clase de referencia.\n",
        "\n",
        "-   Por ejemplo, no es ideal para conjuntos de datos desequilibrados. Cuando una clase es mucho más frecuente que la otra, la precisión puede ser engañosa.\n",
        "\n",
        "## Un ejemplo\n",
        "\n",
        "-   Digamos que deseamos crear un clasificador que nos diga si un cliente de una empresa de telefonía móvil abandonará el próximo mes.\n",
        "\n",
        "-   Los clientes que abandonan disminuyen significativamente los ingresos de la empresa. Por eso es importante conservar a estos clientes.\n",
        "\n",
        "-   Para retener a ese cliente, la empresa le enviará un mensaje de texto con una oferta para un plan móvil de bajo costo.\n",
        "\n",
        "-   Idealmente, nuestro clasificador identifica correctamente a los clientes que abandonarán, para que obtengan la oferta y, con suerte, se queden.\n",
        "\n",
        "## \n",
        "\n",
        "-   En otras palabras, queremos evitar tomar decisiones equivocadas sobre clientes que abandonarán.\n",
        "\n",
        "-   Las decisiones equivocadas sobre los clientes leales no son tan relevantes.\n",
        "\n",
        "-   Porque si clasificamos a un cliente leal como uno que abandonará, el cliente obtendrá una buena oferta. Probablemente pagará menos pero se quedará de todos modos.\n",
        "\n",
        "## Otro ejemplo\n",
        "\n",
        "-   Otro ejemplo es desarrollar un algoritmo (clasificador) que pueda identificar rápidamente a pacientes que puedan tener una enfermedad rara y necesiten una evaluación médica más exhaustiva y costosa.\n",
        "\n",
        "-   El clasificador debe tomar decisiones correctas sobre los pacientes con la enfermedad rara, para que sean evaluados y eventualmente tratados.\n",
        "\n",
        "-   Un paciente sano al que se clasifica erróneamente con la enfermedad sólo incurrirá en algunos dólares extra para pagar el siguiente estudio. Sólo para descubrir que el paciente no tiene la enfermedad.\n",
        "\n",
        "## Métricas especificas de clasificación\n",
        "\n",
        "Para superar esta limitación de exactitud y tasa de error, existen varias métricas específicas de clase. Los más populares son:\n",
        "\n",
        "-   [**Sensibilidad**]{style=\"color:darkblue;\"} o *recall*\n",
        "\n",
        "-   [**Presición**]{style=\"color:darkgreen;\"}\n",
        "\n",
        "-   **Error tipo I**\n",
        "\n",
        "Estas métricas se calculan de la matriz de confusión.\n",
        "\n",
        "## \n",
        "\n",
        "![](images/classspecific_metrics.png){fig-align=\"center\"}\n",
        "\n",
        "[**Sensibilidad**]{style=\"color:darkblue;\"} o *recall* = OO/(OO + OR) “¿Cuántos registros de la clase objetivo predijimos correctamente?”\n",
        "\n",
        "## \n",
        "\n",
        "![](images/classspecific_metrics.png){fig-align=\"center\"}\n",
        "\n",
        "[**Presición**]{style=\"color:darkgreen;\"} = OO/(OO + RO) ¿Cuántos de los registros que predijimos como de clase objetivo fueron clasificados correctamente?\n",
        "\n",
        "## \n",
        "\n",
        "![](images/classspecific_metrics.png){fig-align=\"center\"}\n",
        "\n",
        "**Error tipo I** = RO/(RO + RR) “¿Cuántos de los registros de referencia predijimos incorrectamente como de objetivo?”\n",
        "\n",
        "## Discusión\n",
        "\n",
        "-   Generalmente existe un compromiso entre sensibilidad y error de tipo I.\n",
        "\n",
        "-   Intuitivamente, aumentar la sensibilidad de un clasificador probablemente genere un aumento del error tipo I, porque se predicen más observaciones como positivas.\n",
        "\n",
        "-   Las posibles compensaciones entre sensibilidad y error de tipo I pueden ser apropiadas cuando existen diferentes sanciones o costos asociados con cada tipo de error.\n",
        "\n",
        "## Ejemplo\n",
        "\n",
        "Asumiendo que la clase de interés o objetivo es “large”\n",
        "\n",
        "-   Sensibilidad = 566/(566 + 214) = 0.726\n",
        "\n",
        "-   Precisión = 566/(566 + 156) = 0.783\n",
        "\n",
        "-   Error Tipo 1 = 156/(156+655) = 0.192\n",
        "\n",
        "## Actividad 2.1: Clasificación y métricas (cooperative mode)\n",
        "\n",
        "Juntate con un compañero.\n",
        "\n",
        "Utilizando los datos de la tabla “weight-height.csv” aplica el procedimiento CART para construir un árbol de decisión útil para predecir el sexo de una persona a partir de su peso y su estatura.\n",
        "\n",
        "En este ejemplo las variables predictoras son continuas y la variable a predecir es binaria.\n",
        "\n",
        "## \n",
        "\n",
        "Interpreta los valores de Precision, Exactitud, Sensibilidad y Error Tipo 1 para el conjunto de validación. Si el software no los reporta haz los cálculos a partir de la matriz de confusión. Utiliza “Female” como clase objetivo.\n",
        "\n",
        "Discute sobre la efectividad del modelo resultante.\n",
        "\n",
        "# *K* vecinos cercanos\n",
        "\n",
        "Es un algoritmo de aprendizaje supervisado que usa la proximidad para hacer clasificaciones o predicciones sobre la agrupación de un punto de datos individual.\n",
        "\n",
        "**Idea básica**: predecir una nueva observación utilizando las K observaciones más cercanas en el conjunto de datos de entrenamiento.\n",
        "\n",
        "Para predecir la respuesta de una nueva observación, K-NN utiliza los K vecinos (observaciones) más cercanos en [***terminos de los predictores!***]{style=\"color:aqua;\"}\n",
        "\n",
        "La respuesta prevista para la nueva observación es la respuesta más común de los K vecinos.\n",
        "\n",
        "## El algoritmo tiene 3 pasos\n",
        "\n",
        "1.  Elige el numero de vecinos más cercanos (K).\n",
        "\n",
        "2.  Para una observación nueva, encuentra las K observaciones más cercanas en los datos de entrenamiento (ignorando la respuesta).\n",
        "\n",
        "3.  Para la observación nueva, el algoritmo predice el valor de la respuesta mas común entre las K observaciones más cercanas.\n",
        "\n",
        "## \n",
        "\n",
        "Supongamos que tenemos dos grupos: el grupo rojo y el grupo verde. La recta numérica muestra el valor de una variable para nuestros datos de entrenamiento.\n",
        "\n",
        "Llega una nueva observación y no sabemos a qué grupo pertenece.\n",
        "\n",
        "![](images/ball_example.png){fig-align=\"center\"}\n",
        "\n",
        "Si hubiéramos elegido K=3, entonces los tres vecinos más cercanos votarían a qué grupo pertenece la nueva observación.\n",
        "\n",
        "## \n",
        "\n",
        "Usando $K = 3$, son 2 votos para \"genuino\" y 2 para \"falso\". Entonces clasificamos como \"geniunio\".\n",
        "\n",
        "![](images/ball_example2.png){fig-align=\"center\"}\n",
        "\n",
        "La cercanía se basa en la distancia Euclidiana.\n",
        "\n",
        "## Detalles de implementación\n",
        "\n",
        "**Empates**\n",
        "\n",
        "-   Si hay más de *K* vecinos mas cercanos, incluyelos todos.\n",
        "\n",
        "-   Si hay un empate en la votación, fija una regla para romper el empate. Por ejemplo, seleccionar la clase aleatoriamente.\n",
        "\n",
        "## \n",
        "\n",
        "***KNN utiliza la distancia euclidiana entre puntos***. Entonces ignora las unidades.\n",
        "\n",
        "-   Ejemplo: dos predictores: altura en cm y extensión de brazos en pies. Compare dos personas: (152.4, 1.52) y (182.88, 1.85).\n",
        "\n",
        "-   Estas personas están separadas por 30.48 unidades de distancia en la primera variable, pero sólo por 0.33 unidades en la segunda.\n",
        "\n",
        "-   Por lo tanto, el primer predictor juega un papel mucho más importante en la clasificación y puede impulsar los resultados de modo que la segunda variable se vuelva inútil.\n",
        "\n",
        "## \n",
        "\n",
        "Como primer paso, ¡debemos de transformar los predictores para que tengan las mismas unidades!\n",
        "\n",
        "Esto requiere un proceso de estandarización de los predictores, que se hace en Python.\n",
        "\n",
        "## Estandarización\n",
        "\n",
        "</br>\n",
        "\n",
        "La estandarización se refiere a *centrar* y *escalar* cada predictor numérico individualmente. Esto coloca a todos los predictores en la misma escala.\n",
        "\n",
        "Para **centrar** una variable predictora, se resta el valor promedio del predictor de todos los valores.\n",
        "\n",
        "Por lo tanto, el predictor centrado tiene una media cero (es decir, su valor promedio es cero).\n",
        "\n",
        "## \n",
        "\n",
        "</br>\n",
        "\n",
        "Para **escalar** un predictor, cada uno de sus valores se divide entre su desviación estándar.\n",
        "\n",
        "Al escalar los datos, los valores tienen una desviación estándar común de uno.\n",
        "\n",
        "En términos matemáticos, estandarizamos un predictor como:\n",
        "\n",
        "$${\\color{blue} \\tilde{X}_{i}} = \\frac{{ X_{i} - \\bar{X}}}{ \\sqrt{\\frac{1}{n -1} \\sum_{i=1}^{n} (X_{i} - \\bar{X})^2}},$$\n",
        "\n",
        "con $\\bar{X} = \\sum_{i=1}^n \\frac{x_i}{n}$.\n",
        "\n",
        "## Ejemplo 1 (cont.)\n",
        "\n",
        "Usamos los cinco predictores numéricos del conjunto de datos `complete_sbAuto`.\n"
      ],
      "id": "60e17253"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "\n",
        "#complete_sbAuto.head()"
      ],
      "id": "eed40f5e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Dos predictores en unidades originales\n",
        "\n",
        "Considere el conjunto de datos `complete_sbAuto` creado previamente. Considere dos puntos en el gráfico: $(175, 5140)$ y $(69, 1613)$.\n",
        "\n",
        "::::: columns\n",
        "::: {.column width=\"50%\"}"
      ],
      "id": "cfacd85a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "#plt.figure(figsize=(5,5))\n",
        "#sns.scatterplot(data = complete_sbAuto, x = 'horsepower', y = 'weight')\n",
        "#plt.scatter(x = 175, y = 5140, color = 'red')\n",
        "#plt.scatter(x = 69, y = 1613, color = 'red')\n",
        "#plt.xlabel('Horsepower', fontsize=14)\n",
        "#plt.ylabel('Weight', fontsize=14)\n",
        "#plt.show()"
      ],
      "id": "2fa70bb7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.column width=\"50%\"}\n",
        "</br>\n",
        "\n",
        "La distancia entre estos puntos es $\\sqrt{(69 - 175)^2 + (1613-5140)^2}$ $= \\sqrt{11236 + 12439729}$ $= 3528.592$.\n",
        ":::\n",
        ":::::\n",
        "\n",
        "## Estandarización en Python\n",
        "\n",
        "</br>\n",
        "\n",
        "Para estandarizar predictores **numéricos**, usamos la función `StandardScaler()`. Además, aplicamos la función a las variables mediante la función `fit_transform()`.\n",
        "\n",
        "</br>\n"
      ],
      "id": "55088b1e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "\n",
        "#scaler = StandardScaler()\n",
        "#Xs = scaler.fit_transform(complete_sbAuto)"
      ],
      "id": "0f62a020",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## \n",
        "\n",
        "Lamentablemente, el objeto resultante no es un marco de datos de Pandas. Por lo tanto, lo convertimos a este formato.\n"
      ],
      "id": "4c72a452"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "\n",
        "#scaled_df = pd.DataFrame(Xs, columns = complete_sbAuto.columns)\n",
        "#scaled_df.head()"
      ],
      "id": "6791c08d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Dos predictores en unidades estandarizadas\n",
        "\n",
        "En la nueva escala, los dos puntos ahora son: $(1.82, 2.53)$ y $(-0.91, -1.60)$.\n",
        "\n",
        "::::: columns\n",
        "::: {.column width=\"50%\"}"
      ],
      "id": "262dedf4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: true\n",
        "#| fig-align: center\n",
        "\n",
        "#plt.figure(figsize=(5,5))\n",
        "#sns.scatterplot(data = scaled_df, x = 'horsepower', y = 'weight')\n",
        "#plt.scatter(x = 1.83, y = 2.54, color = 'red')\n",
        "#plt.scatter(x = -0.90, y = -1.60, color = 'red')\n",
        "#plt.xlabel('Standardized horsepower', fontsize=14)\n",
        "#plt.ylabel('Standardized weight', fontsize=14)\n",
        "#plt.show()"
      ],
      "id": "f24bfdd3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.column width=\"50%\"}\n",
        "</br>\n",
        "\n",
        "La distancia entre estos puntos es $\\sqrt{(-0.91 - 1.82)^2 + (-1.60-2.53)^2}$ $= \\sqrt{7.45 + 17.05} = 4.95$.\n",
        ":::\n",
        ":::::\n",
        "\n",
        "## Discusión\n",
        "\n",
        "K-NN es intuitivo y sencillo y puede producir predicciones decentes. Sin embargo, K-NN tiene algunas desventajas:\n",
        "\n",
        "-   Cuando el conjunto de datos de entrenamiento es muy grande, K-NN es computacionalmente costoso. Esto se debe a que, para predecir una observación, necesitamos calcular la distancia entre la observación y todas las demás en el conjunto de datos. (“Aprendiz perezoso”).\n",
        "\n",
        "-   En este caso, un arbol de decisión es mas ventajoso porque es fácil de construir, almacenar, y hacer predicciones con él.\n",
        "\n",
        "## \n",
        "\n",
        "-   El rendimiento predictivo de K-NN se deteriora a medida que aumenta el número de predictores.\n",
        "\n",
        "-   Esto se debe a que la distancia esperada al vecino más cercano aumenta drásticamente con el número de predictores, a menos que el tamaño del conjunto de datos aumente exponencialmente con este número.\n",
        "\n",
        "-   Esto se conoce como la ***maldición de la dimensionalidad***.\n",
        "\n",
        "![](images/clipboard-72810347.png)\n",
        "\n",
        "<https://aiaspirant.com/curse-of-dimensionality/>\n",
        "\n",
        "# [Return to main page](https://alanrvazquez.github.io/TEC-IN1002B-Website/)"
      ],
      "id": "81f02ea0"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}